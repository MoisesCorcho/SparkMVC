Section 4: controllers and actions

= DISPATCH METHOD IN ROUTER
In this section, in the router we add a dispatch method which firstly verify with the pairing() function if the URL match with any of the routes that we created and then takes the URL and instantiate the controller and call the method
that we require in the URL. 
this function also converts the class name (controller) to the StudlyCase and the method name to the camelCase, we do that with other two functions we created.
We call this dispatch method in the at the bottom of the index.php (FrontController).

= NAMESPACES
We add namespaces to our classes so we can access then throug the statement "use" e.g. use App\Controller;
We modify the dispatch method in the Router to find the classes through its namespaces.

= AUTOLOADER
we add an autoloader in the Router so we can not to require the classes explicitly.
we use the "spl_autoload_register" function

= REMOVE QUERY STRING VARIABLES
We remove the query strings from the URL with a function we created and we placed at the top of dispatch mehtod. We remove query strings because with them the URL does not match with the routes in our Router.
We can always access to query params through the superglobal $_GET

= CREATE A BASE CONTROLLER
We create a base controller which receives the params that we sent from the Router and store them into a protected array attribute that initialize in the constructor. All other controllers will have access to those params because all of this controllers will extends the base controller.
finally, in the router we pass the params to the controller, those params are received in the construct of the base controller so we have access to them in each controller that extends it. We must remember that normally the Superclass constructor is executed first than the subclass constructor.

= ACTION FILTERS
- My explanation
We create a system which can use action filters to do things before and after an action is executed in controllers. we do that thanks to the __call function that is executed when we try to call a non-existing or non-public method inside a class, so we add a "Action" sufix to methods, then when we try to acccess to the methods, they wont exist in the controller because now have the Action sufix, so the __call method will be called, and inside of it we add Sufix Action to method name and then we try to find again the method which now will exist.

- Teachers explanation
Action filters
We used the __call  magic method to add action filters to our controller actions. The before  action filter can be used to run code before every action method in a controller. To achieve this, we changed the name of the action methods in our controllers to have the "Action" suffix. So for example an index action would actually be a method called indexAction .

When a request comes into the framework, the Router will create a controller object, then try to call an action method on that object. The name of this action method doesn't contain the "Action" suffix, so in the Core/Controller class, the __call  method will add "Action" to the end of the action name before calling the method.

For example, let's say we have this route in our application:

$router->add('{controller}/{action}'); 

and we access the URL

http://localhost/posts/index 

The router will match the {controller}  part of the route to "posts", and the {action}  part of the route to "index". It will create a controller object of the class "Posts", and then execute the "index" method on that object.

The controller class however doesn't contain a method called "index", rather a method called "indexAction". When the router calls the index  method on the controller, the __call  method is executed, which adds the "Action" suffix and actually calls the indexAction  method.

In this same __call  method, the before  method is executed before the indexAction  method is called. One of the uses for this is to require a user to login before they can access the requested method. For example, if a user tries to access this URL:

http://localhost/posts/index 

and in the before  filter method you're checking to see if they've logged in, for example using the session:

protected function before()
{       
    if ( ! isset($_SESSION["user_id"])) {
        return false;
    }
}
If they haven't logged in, then the before filter returns false and they don't get access to the originally requested method. They have to login first. Once they've logged in, the before filter will let them access that method.

= FIXING SECURITY PROBLEMS

The security hole
The before filter will prevent a user accessing the indexAction  method if they're not logged in when they try the following URL:

http://localhost/posts/index 

However, if the user tries the following URL:

http://localhost/posts/indexAction 

then the before filter is bypassed and the action will run. This is because this method exists, so the __call  method doesn't run. The action method is executed directly, so if login is being required in the before filter, this method could be executed if the user isn't logged in.

Note that this is only a problem if someone knows how the framework works, and the action is coming from a variable in the route.

The fix
There are two ways to fix it. One would be to make all the action methods protected:

protected function indexAction()
{
   ...
}
So they can't be called directly. However it would be easy to forget to do this.

A better fix is to not allow the action coming from the URL to contain the "Action" suffix. We do that in the dispatch  method in the router. At the moment we have this code:

if (is_callable([$controller_object, $action])) {
    $controller_object->$action();
} else {
    throw new \Exception("Method $action (in controller $controller) not found");
}
It turns out that since we introduced the __call  magic method in the controller, we don't actually need the call to is_callable , as this will now always return true. So we can replace this line with a check that the action name doesn't end in "Action", and we can also change the error message:

if (preg_match('/action$/i', $action) == 0) {
    $controller_object->$action();
} else {
    throw new \Exception("Method $action in controller $controller cannot be called directly - remove the Action suffix to call this method");
}
This code uses the preg_match function to check that the name of the action doesn't end in "Action" (or "action" - the "i" flag means it's case insensitive). If it doesn't, then the method is called. If it does, then an exception is raised.

So with this change, if someone tries to access the following URL:

http://localhost/posts/indexAction 

an exception is raised. The following URL however still works as it should:

http://localhost/posts/index 

A simple fix to close the potential security hole. Updated code is attached to this lecture.


= ADD A ROUTE NAMESPACE OPTION
we added the option to be able to pass a namespace option as an associative array when defining routes, to specify the controller namespace.

-----------------------------------------------------
Conclusion                                          |
-----------------------------------------------------
Throughout this course, you've built a complete MVC framework, from scratch. 
Including: 

=> code organised into models, views and controllers, making it easy to separate the application 

=> code from the presentation code and making it easier to write and maintain your application;

=> An advanced router, with pretty URLs and route variables using regular expressions; 

=> Classes organised into namespaces and loaded automatically on demand without having to explicitly require 
them using the Composer utility; 

=> Controllers that decide what response to return to the user, including action filters to allow you 
to run code before each action in a controller - useful for authentication; 

=> Views that just contain presentation code. And we also added the Blade template engine to make the 
views even easier to create; 

=> Models to handle the data in your application, including only connecting to the database when necessary; 

=> Configuration and error handling that you can change between environments, depending on whether you're 
developing, or in production; 

=> And above all, in doing all this, you can now understand just how an MVC framework is put together. 
So if you want to learn a framework like Laravel, Phalcon or CakePHP, it'll be much easier.
